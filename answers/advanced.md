## <a name="arrow"></a>Что такое стрелочные/лямбда функции?

Функция жирной стрелки - это сокращенный синтаксис для определения функциональных выражений анонимных функций. Это похоже на лямбда-функции в других языках. Функция стрелки позволяет пропустить ключевое слово функции и написать более лаконичный код.

## <a name="rest"></a>Объясните Rest параметры и правила объявления таких параметров.

Rest параметры позволяют передавать функции различное количество аргументов (ноль или более). Это полезно, когда вы не знаете, сколько параметров получит функция. Все аргументы после оставшегося символа `...` будут сохранены в массиве.

Например:

```typescript
function Greet(greeting: string, ...names: string[]) {
	return greeting + " " + names.join(", ") + "!";
}

Greet("Hello", "Steve", "Bill"); // returns "Hello Steve, Bill!"

Greet("Hello"); // returns "Hello !"
```

## <a name="triple-slash"></a>Что такое Triple-Slash директивы?

Директивы с тройной косой чертой - это однострочные комментарии, содержащие тег XML для использования в качестве директив компилятора. Каждая директива указывает, что загружать в процессе компиляции. Директивы с тройной косой чертой работают только в верхней части своего файла и будут рассматриваться как обычные комментарии в любом другом месте файла.

- `/// <reference path="..." />` - является наиболее распространенной директивой и определяет зависимость между файлами.

- `/// <reference types="..." />` - похож на path, но определяет зависимость для пакета.

- `/// <reference lib="..." />` - позволяет явно включить встроенный файл lib.

## <a name="omit"></a>Что делает тип Omit?

Omit - это форма служебного типа, которая упрощает преобразования общих типов. Omit позволяет вам создать тип, передав текущий тип и выбрав ключи, которые нужно пропустить в новом типе.

```typescript
Omit<Type, Keys>;
```

Например:

```typescript
interface Todo {
	title: string;
	description: string;
	completed: boolean;
	createdAt: number;
}

type TodoPreview = Omit<Todo, "description">;
```

## <a name="overload"></a>Что такое перегрузка функции в TypeScript?

Перегрузка функции - это способ определить функцию с несколькими вариантами типов и реализаций. Перегруженная функция может иметь несколько определений, которые отличаются по количеству и типу параметров.

```typescript
function add(a: string, b: string): string;
function add(a: number, b: number): number;
function add(a: any, b: any): any {
	return a + b;
}
```

## <a name="optional"></a>Как сделать все свойства интерфейса необязательными?

Вы можете использовать тип `Partial`, чтобы легко сделать все свойства необязательными.

```typescript
Partial<Type>;
```

## <a name="unknown"></a>Когда нужно использовать ключевое слово unknown?

Вам следует использовать unknown, если вы не знаете, какой тип ожидать заранее, но хотите назначить его позже, и ключевое слово any не будет работать.

## <a name="decorators"></a>Что такое декораторы и к чему их можно применить?

Декоратор - это особый вид объявления, который позволяет вам изменять классы или члены классов сразу, помечая их аннотацией `@<name>`. Каждый декоратор должен ссылаться на функцию, которая будет оцениваться во время выполнения.

Например, декоратор @sealed будет соответствовать запечатанной функции. Все, что помечено `@sealed`, будет использоваться для оценки запечатанной функции.

```typescript
function sealed(target) {
	// do something with 'target' ...
}
```

Их можно прикрепить к:

- Объявлениям классов
- Методам
- Свойствам-аксессорам
- Свойствам
- Параметрам

По умолчанию декораторы не включены. Чтобы включить их, вы должны отредактировать поле `experimentalDecorators` в параметрах компилятора в файле tsconfig.json или в командной строке.

## <a name="awaited"></a>Что такое тип awaited?

Тип Awaited - это новый утилитарный тип, введенный в TypeScript 4.5. Этот тип предназначен для представления действий, таких как ожидание (await) в асинхронных функциях и метода .then() для обработки промисов - прежде всего, способа рекурсивной распаковки промисов.

```typescript
type Awaited<T> = T extends PromiseLike<infer U> ? Awaited<U> : T;
```
